# 小结
## 929
是一道水题，对string的方法熟悉就能过。  
## 930
可以暴力，也可以用哈希表。用哈希表的话思想是这样的：  
用```Map[x]```表示到目前为止和为```x```的子序列个数，我们计算到目前为止的数组元素和```Cur```， ```Cur = A[0] + A[1] + ... + A[i]```，假设目标和是```S```，且```D = Cur - S```，那么就有```Map[D]```个序列，满足：```D = A[0] + A[1] + ... + A[k], k <= i```，换句话说，就有```A[k+1] + A[k+2] + ... + A[i] = S```，且这样的序列也有```Map[D]```个。  
可以进一步用一个例子来说明：```[1, -1, 1, 0, 1, 1]```，目标和是2，如果此时```Cur = 1 + (-1) + 1 + 0 + 1 + 1 = 3```，而```3 - 2 = 1```，说明前面有```Map[1]```个和为1的序列，即```[1] [1 -1 1] [1 -1 1 0] [-1 1 0 1] [1 0] [0 1]```（方便起见就不加逗号了...），这也意味着相应有6个和为2的序列：```[1 1] [0 1 1] [1 0 1] [1 -1 1 0 1] [-1 1 0 1 1] [1 -1 1 0 1]```。因为我们总是可以从和为1的序列中取出一些数来让另一个序列和为2，这样的取法有```Map[1]```种。
## 931
dp  
处理数组的时候为了方便可以使用“镶边法”，人为添上前后两行。
## 932  
beautiful的性质是：对于满足```i < k < j```的```i, j, k```，```2*A[k] != A[i] + A[j]```。
如果```N = 1```，返回```[1]```  
如果```N = 2```，返回```[1, 2]```或```[2, 1]```均可  
如果```N = 3```，返回```[1, 3, 2]```或```[2, 1, 3]```或```[2, 3, 1]```或```[3, 1, 2]```均可  
......  
现在希望能发现一些pattern来生成满足这种性质的数组，我们可以按数字的奇偶性分成两堆:```[奇数，偶数]```，这样，从奇数堆里取一个数字加上偶数堆里的一个数字还是奇数，满足上述性质，再分别考察```[奇数]```和```[偶数]```，它们各自是有可能违反这个性质的，例如```[1, 5, 9]```。但是，我们是从```[1]```开始生成，并且可以证明对从一开始就保持beautiful性质的序列做加法和乘法，beautiful的性质还是会保持。例如```2*(A[k] + x) = 2*A[k] + x + x != (A[i] + x) + (A[j] + x)```，所以后续不会生成违反这种性质的序列。  
```
vector<int> beautifulArray(int N) {
    vector<int> res = {1};
    while (res.size() < N) {
        vector<int> tmp;
        for (int i : res) if (i * 2 - 1 <= N) tmp.push_back(i * 2 - 1);
        for (int i : res) if (i * 2 <= N) tmp.push_back(i * 2);
        res = tmp;
    }
    return res;
}
```
